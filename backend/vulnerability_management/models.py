"""
Vulnerability Management Models
"""
from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone
import json

class VulnerabilityScanner(models.Model):
    """
    Vulnerability scanner configurations (OpenVAS, Nessus, etc.)
    """
    
    SCANNER_TYPES = [
        ('openvas', 'OpenVAS'),
        ('nessus', 'Nessus'),
        ('qualys', 'Qualys'),
        ('rapid7', 'Rapid7'),
        ('custom', 'Custom Scanner'),
    ]
    
    STATUS_CHOICES = [
        ('active', 'Active'),
        ('inactive', 'Inactive'),
        ('maintenance', 'Maintenance'),
        ('error', 'Error'),
    ]
    
    name = models.CharField(max_length=255)
    scanner_type = models.CharField(max_length=20, choices=SCANNER_TYPES)
    host = models.CharField(max_length=255)
    port = models.IntegerField(default=9390)
    username = models.CharField(max_length=100, blank=True)
    password = models.CharField(max_length=255, blank=True)  # Should be encrypted
    api_key = models.CharField(max_length=500, blank=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='active')
    description = models.TextField(blank=True)
    last_connection_test = models.DateTimeField(null=True, blank=True)
    connection_status = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    created_by = models.ForeignKey(User, on_delete=models.CASCADE)
    configuration = models.JSONField(default=dict)
    
    class Meta:
        db_table = 'vulnerability_scanners'
    
    def __str__(self):
        return f"{self.name} ({self.scanner_type})"

class VulnerabilityScanConfig(models.Model):
    """
    Vulnerability scan configurations and policies
    """
    
    SCAN_TYPES = [
        ('full', 'Full System Scan'),
        ('discovery', 'Discovery Scan'),
        ('authenticated', 'Authenticated Scan'),
        ('web_application', 'Web Application Scan'),
        ('database', 'Database Scan'),
        ('compliance', 'Compliance Scan'),
        ('custom', 'Custom Scan'),
    ]
    
    SCHEDULE_TYPES = [
        ('once', 'One Time'),
        ('daily', 'Daily'),
        ('weekly', 'Weekly'),
        ('monthly', 'Monthly'),
        ('custom', 'Custom Schedule'),
    ]
    
    name = models.CharField(max_length=255)
    scan_type = models.CharField(max_length=20, choices=SCAN_TYPES)
    scanner = models.ForeignKey(VulnerabilityScanner, on_delete=models.CASCADE)
    targets = models.JSONField(default=list)  # List of IP addresses, ranges, hostnames
    port_range = models.CharField(max_length=100, default='1-65535')
    
    # Scan settings
    max_hosts = models.IntegerField(default=10)
    max_checks = models.IntegerField(default=5)
    timeout = models.IntegerField(default=3600)  # seconds
    scan_policy = models.TextField(blank=True)  # Scanner-specific policy
    
    # Authentication
    use_credentials = models.BooleanField(default=False)
    ssh_credentials = models.JSONField(default=dict)
    smb_credentials = models.JSONField(default=dict)
    snmp_credentials = models.JSONField(default=dict)
    
    # Scheduling
    schedule_type = models.CharField(max_length=20, choices=SCHEDULE_TYPES, default='once')
    schedule_time = models.TimeField(null=True, blank=True)
    schedule_days = models.JSONField(default=list)  # For weekly/custom schedules
    is_enabled = models.BooleanField(default=True)
    
    # Metadata
    description = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    created_by = models.ForeignKey(User, on_delete=models.CASCADE)
    
    class Meta:
        db_table = 'vulnerability_scan_configs'
    
    def __str__(self):
        return f"{self.name} ({self.scan_type})"

class VulnerabilityScanExecution(models.Model):
    """
    Vulnerability scan execution records
    """
    
    STATUS_CHOICES = [
        ('queued', 'Queued'),
        ('running', 'Running'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('cancelled', 'Cancelled'),
        ('paused', 'Paused'),
    ]
    
    scan_config = models.ForeignKey(VulnerabilityScanConfig, on_delete=models.CASCADE, related_name='executions')
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='queued')
    scanner_task_id = models.CharField(max_length=255, blank=True)  # External scanner task ID
    
    # Execution details
    started_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    duration = models.DurationField(null=True, blank=True)
    progress_percentage = models.IntegerField(default=0)
    
    # Results summary
    hosts_scanned = models.IntegerField(default=0)
    vulnerabilities_found = models.IntegerField(default=0)
    critical_vulns = models.IntegerField(default=0)
    high_vulns = models.IntegerField(default=0)
    medium_vulns = models.IntegerField(default=0)
    low_vulns = models.IntegerField(default=0)
    info_vulns = models.IntegerField(default=0)
    
    # Raw results
    scan_results = models.JSONField(default=dict)
    error_message = models.TextField(blank=True)
    logs = models.TextField(blank=True)
    
    # User context
    initiated_by = models.ForeignKey(User, on_delete=models.CASCADE)
    
    class Meta:
        db_table = 'vulnerability_scan_executions'
        ordering = ['-started_at']
    
    def __str__(self):
        return f"Scan {self.id} - {self.scan_config.name} ({self.status})"

class VulnerabilityFinding(models.Model):
    """
    Individual vulnerability findings from scans
    """
    
    SEVERITY_LEVELS = [
        ('critical', 'Critical'),
        ('high', 'High'),
        ('medium', 'Medium'),
        ('low', 'Low'),
        ('info', 'Informational'),
    ]
    
    STATUS_CHOICES = [
        ('new', 'New'),
        ('confirmed', 'Confirmed'),
        ('false_positive', 'False Positive'),
        ('remediated', 'Remediated'),
        ('accepted', 'Risk Accepted'),
        ('investigating', 'Investigating'),
    ]
    
    scan_execution = models.ForeignKey(VulnerabilityScanExecution, on_delete=models.CASCADE, related_name='findings')
    
    # Vulnerability details
    cve_id = models.CharField(max_length=20, blank=True)
    vulnerability_id = models.CharField(max_length=100)  # Scanner-specific ID
    title = models.CharField(max_length=500)
    description = models.TextField()
    severity = models.CharField(max_length=10, choices=SEVERITY_LEVELS)
    cvss_score = models.FloatField(null=True, blank=True)
    cvss_vector = models.CharField(max_length=200, blank=True)
    
    # Affected asset
    host_ip = models.GenericIPAddressField()
    hostname = models.CharField(max_length=255, blank=True)
    port = models.IntegerField(null=True, blank=True)
    protocol = models.CharField(max_length=10, blank=True)
    service = models.CharField(max_length=100, blank=True)
    
    # Impact and risk
    risk_score = models.FloatField(default=0.0)
    exploitability = models.CharField(max_length=20, blank=True)
    threat_level = models.CharField(max_length=20, blank=True)
    
    # Status and remediation
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='new')
    first_detected = models.DateTimeField(auto_now_add=True)
    last_detected = models.DateTimeField(auto_now=True)
    remediation_advice = models.TextField(blank=True)
    remediation_effort = models.CharField(max_length=20, blank=True)  # low, medium, high
    
    # References and evidence
    references = models.JSONField(default=list)
    evidence = models.TextField(blank=True)
    proof_of_concept = models.TextField(blank=True)
    
    # Assignment and tracking
    assigned_to = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
    due_date = models.DateTimeField(null=True, blank=True)
    comments = models.TextField(blank=True)
    
    # Metadata
    scanner_output = models.JSONField(default=dict)
    tags = models.JSONField(default=list)
    
    class Meta:
        db_table = 'vulnerability_findings'
        ordering = ['-cvss_score', '-first_detected']
        indexes = [
            models.Index(fields=['severity', 'status']),
            models.Index(fields=['host_ip', 'status']),
            models.Index(fields=['cve_id']),
        ]
    
    def __str__(self):
        return f"{self.cve_id or self.vulnerability_id} - {self.host_ip} ({self.severity})"

class VulnerabilityDatabase(models.Model):
    """
    Vulnerability database for threat intelligence correlation
    """
    
    cve_id = models.CharField(max_length=20, unique=True)
    title = models.CharField(max_length=500)
    description = models.TextField()
    cvss_v3_score = models.FloatField(null=True, blank=True)
    cvss_v3_vector = models.CharField(max_length=200, blank=True)
    cvss_v2_score = models.FloatField(null=True, blank=True)
    cvss_v2_vector = models.CharField(max_length=200, blank=True)
    
    # Temporal information
    published_date = models.DateTimeField()
    modified_date = models.DateTimeField()
    
    # Vulnerability details
    cwe_id = models.CharField(max_length=20, blank=True)  # Common Weakness Enumeration
    attack_vector = models.CharField(max_length=20, blank=True)
    attack_complexity = models.CharField(max_length=20, blank=True)
    privileges_required = models.CharField(max_length=20, blank=True)
    user_interaction = models.CharField(max_length=20, blank=True)
    scope = models.CharField(max_length=20, blank=True)
    
    # Impact scores
    confidentiality_impact = models.CharField(max_length=10, blank=True)
    integrity_impact = models.CharField(max_length=10, blank=True)
    availability_impact = models.CharField(max_length=10, blank=True)
    
    # Affected products
    affected_products = models.JSONField(default=list)
    vendor_advisories = models.JSONField(default=list)
    references = models.JSONField(default=list)
    
    # Exploitation
    exploitability_score = models.FloatField(null=True, blank=True)
    exploit_code_maturity = models.CharField(max_length=20, blank=True)
    known_exploits = models.BooleanField(default=False)
    exploit_references = models.JSONField(default=list)
    
    # Intelligence
    threat_intelligence = models.JSONField(default=dict)
    trending_score = models.FloatField(default=0.0)
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'vulnerability_database'
        ordering = ['-cvss_v3_score', '-published_date']
    
    def __str__(self):
        return f"{self.cve_id} - {self.title[:50]}"

class PatchIntelligence(models.Model):
    """
    Patch intelligence and prioritization
    """
    
    PATCH_STATUS = [
        ('available', 'Available'),
        ('testing', 'In Testing'),
        ('approved', 'Approved'),
        ('deployed', 'Deployed'),
        ('not_available', 'Not Available'),
        ('workaround', 'Workaround Available'),
    ]
    
    vulnerability = models.ForeignKey(VulnerabilityDatabase, on_delete=models.CASCADE, related_name='patches')
    
    # Patch details
    patch_id = models.CharField(max_length=100)
    patch_title = models.CharField(max_length=255)
    vendor = models.CharField(max_length=100)
    product = models.CharField(max_length=100)
    version = models.CharField(max_length=50)
    
    # Status and priority
    status = models.CharField(max_length=20, choices=PATCH_STATUS, default='available')
    priority_score = models.FloatField(default=0.0)
    criticality = models.CharField(max_length=10)
    
    # Patch information
    release_date = models.DateTimeField()
    patch_size = models.CharField(max_length=50, blank=True)
    prerequisites = models.JSONField(default=list)
    installation_notes = models.TextField(blank=True)
    reboot_required = models.BooleanField(default=False)
    
    # Risk assessment
    patch_risk_score = models.FloatField(default=0.0)
    compatibility_issues = models.JSONField(default=list)
    rollback_complexity = models.CharField(max_length=20, blank=True)
    
    # Deployment tracking
    affected_systems = models.IntegerField(default=0)
    systems_patched = models.IntegerField(default=0)
    deployment_window = models.CharField(max_length=100, blank=True)
    
    # References
    vendor_advisory = models.URLField(blank=True)
    download_url = models.URLField(blank=True)
    documentation_url = models.URLField(blank=True)
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'patch_intelligence'
        ordering = ['-priority_score', '-release_date']
    
    def __str__(self):
        return f"{self.patch_id} - {self.product} ({self.status})"

class ZeroDayTracking(models.Model):
    """
    Zero-day vulnerability tracking and alerts
    """
    
    ALERT_LEVELS = [
        ('critical', 'Critical'),
        ('high', 'High'),
        ('medium', 'Medium'),
        ('low', 'Low'),
        ('watch', 'Watch'),
    ]
    
    STATUS_CHOICES = [
        ('active', 'Active Zero-Day'),
        ('patched', 'Patch Released'),
        ('mitigated', 'Mitigated'),
        ('false_alarm', 'False Alarm'),
        ('monitoring', 'Under Monitoring'),
    ]
    
    # Vulnerability details
    identifier = models.CharField(max_length=100, unique=True)
    title = models.CharField(max_length=255)
    description = models.TextField()
    affected_products = models.JSONField(default=list)
    attack_vectors = models.JSONField(default=list)
    
    # Threat assessment
    alert_level = models.CharField(max_length=10, choices=ALERT_LEVELS)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='active')
    threat_score = models.FloatField(default=0.0)
    
    # Discovery information
    discovered_date = models.DateTimeField()
    disclosed_date = models.DateTimeField(null=True, blank=True)
    first_exploit_date = models.DateTimeField(null=True, blank=True)
    patch_release_date = models.DateTimeField(null=True, blank=True)
    
    # Intelligence sources
    discovery_source = models.CharField(max_length=100)
    intelligence_sources = models.JSONField(default=list)
    iocs = models.JSONField(default=list)  # Related IOCs
    
    # Impact assessment
    exploitation_detected = models.BooleanField(default=False)
    widespread_exploitation = models.BooleanField(default=False)
    targeted_attacks = models.BooleanField(default=False)
    potential_impact = models.TextField()
    
    # Mitigation
    mitigation_measures = models.TextField(blank=True)
    workarounds = models.TextField(blank=True)
    detection_rules = models.TextField(blank=True)
    
    # Tracking
    assigned_analyst = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
    last_updated = models.DateTimeField(auto_now=True)
    created_at = models.DateTimeField(auto_now=True)
    
    # References
    references = models.JSONField(default=list)
    vendor_statements = models.JSONField(default=list)
    
    class Meta:
        db_table = 'zero_day_tracking'
        ordering = ['-threat_score', '-discovered_date']
    
    def __str__(self):
        return f"{self.identifier} - {self.title} ({self.alert_level})"

class RiskAssessment(models.Model):
    """
    Risk assessments for vulnerabilities and assets
    """
    
    ASSESSMENT_TYPES = [
        ('vulnerability', 'Vulnerability Risk'),
        ('asset', 'Asset Risk'),
        ('system', 'System Risk'),
        ('network', 'Network Risk'),
    ]
    
    assessment_type = models.CharField(max_length=20, choices=ASSESSMENT_TYPES)
    target_id = models.CharField(max_length=255)  # ID of target (vuln, asset, etc.)
    target_name = models.CharField(max_length=255)
    
    # Risk scores
    base_risk_score = models.FloatField()
    temporal_risk_score = models.FloatField()
    environmental_risk_score = models.FloatField()
    final_risk_score = models.FloatField()
    
    # Risk factors
    likelihood = models.FloatField()  # Probability of exploitation
    impact = models.FloatField()  # Impact if exploited
    asset_value = models.FloatField()  # Value of affected asset
    threat_level = models.FloatField()  # Current threat level
    
    # Context
    business_criticality = models.CharField(max_length=20)
    exposure_level = models.CharField(max_length=20)
    existing_controls = models.JSONField(default=list)
    compensating_controls = models.JSONField(default=list)
    
    # Assessment details
    methodology = models.CharField(max_length=100)
    assessment_date = models.DateTimeField(auto_now_add=True)
    valid_until = models.DateTimeField()
    assessor = models.ForeignKey(User, on_delete=models.CASCADE)
    
    # Risk treatment
    treatment_plan = models.TextField(blank=True)
    risk_acceptance = models.BooleanField(default=False)
    accepted_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True, related_name='accepted_risks')
    acceptance_rationale = models.TextField(blank=True)
    
    # Metadata
    notes = models.TextField(blank=True)
    metadata = models.JSONField(default=dict)
    
    class Meta:
        db_table = 'risk_assessments'
        ordering = ['-final_risk_score', '-assessment_date']
    
    def __str__(self):
        return f"Risk Assessment: {self.target_name} (Score: {self.final_risk_score})"